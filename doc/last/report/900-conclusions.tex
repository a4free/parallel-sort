\section{Conclusions}
\label{sec:900}

As for the programming approaches required by each of the two shared memory parallel libraries, TBB enables a more robust, object oriented approach to separate each different parallelizable task into \textit{Functors}, and allows easy control over task granularity. While that is probably the best choice most of the times, allowing the programmer to focus on the algorithm and letting the library manage most of the thread managment payload, sometimes a more in-depth control is required. For those cases, perhaps OpenMP may be a better choice.

This is not because of better performance, which was not the case shown here, but because TBB does not allow direct control over how the workload gets distributed, or how many threads are spawned. The programmer can only hint or ask how many threads or granularity he wants, but the scheduler may choose to override those values if it assumes they were not the best ones. For algorithm that require an exact control over how many threads are spawned and which one is doing what, this may not be the best approach.
